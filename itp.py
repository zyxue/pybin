#! /usr/bin/env python

"""This is script is incomplete, it's used to produce the itp file for opls,
given the input of all bonds"""

import sys
import re
import copy
from Bio.PDB.Polypeptide import three_to_one
from cg_params import PARAMS

cg_params = PARAMS().value

def read_atoms(itpfile):
    """get the id: resname correspondence for MARTINI when constructing [
    dihedrals ] """
    atoms = {}
    with open(itpfile, 'r') as inf:
        for line in inf:
            if re.search("^(?!;).*\[ *atoms *\]", line):
                # interested block begins here
                break

        for line in inf:
            if re.search("^(?!;).*\[ *bonds *\]", line):
                # interested block ends here
                break
            elif line.startswith(";") or line.startswith("[") or not line.split():
                # pass comment line, empty line or [ contraints ] line in MARTINI
                pass
            else:
                sl = line.split()
                atoms[int(sl[0])] = sl[3]
    print atoms
    return atoms

def read_bond_pairs(itpfile, ff):
    """
    to use this function, a preliminary itp file should have been generated in advance;

    ff could be "martini", "opls";

    if ff="martini", itpfile should be generated by MARTINI relavant script and
    contains the following two lines:
    [ bonds ]
    ;backbone-sidechain bonds
    """

    # flags for the beginning and ending lines of the interested block
    block_beg_end_flags = { 
        "martini": [";backbone-backbone bonds", ";backbone-sidechain bonds"],
        # "martini": [";backbone-backbone bonds", "^(?!;).*\[ *angles *\]"],
        # MARTINI has the "[ constraints ]" section and it only counts BBBB dihedrals
        "opls"   : ["^(?!;).*\[ *bonds *\]", "^(?!;).*\[ *pairs *\]"],
        "cgenff" : ["^(?!;).*\[ *bonds *\]", "^(?!;).*\[ *pairs *\]"],
        }

    bonds = []

    with open(itpfile, 'r') as inf:
        for line in inf:
            if re.search(block_beg_end_flags[ff][0], line):
                # interested block begins here
                break

        for line in inf:
            if re.search(block_beg_end_flags[ff][1], line):
                # interested block ends here
                break
            # elif re.search("^[;\[]", line) or not line.split():
            elif line.startswith(";") or line.startswith("[") or not line.split():
                # pass comment line, empty line or [ contraints ] line in MARTINI
                pass
            else:
                bonds.append([int(i) for i in line.split()[:2]])
                # bonds.append([int(i) for i in line.split()[:2]])
    print bonds
    return bonds


def determine_dihedral(b1, b2, b3):
    rb1 = copy.copy(b1)
    rb2 = copy.copy(b2)
    rb3 = copy.copy(b3)

    rb1.reverse()                                           # reversed bond1
    rb2.reverse()
    rb3.reverse()

    for i in [b1, rb1]:
        for j in [b2, rb2]:
            for k in [b3, rb3]:
                if i[1] == j[0] and j[1] == k[0]:
                    return i + k

def collect_dihedrals(bonds):
    # dihedrals be determined based on bonds info
    dihedrals = []
    for i, b1 in enumerate(bonds):
        for j, b2 in enumerate(bonds):
            for k, b3 in enumerate(bonds):
                if i < j < k:
                    d = determine_dihedral(b1, b2, b3)
                    if d:
                        dihedrals.append(d)
    dihedrals.sort()
    return dihedrals

def print_dihedrals(dihedrals, ft=3):
    """
    if not sure what ft (function_type) should be used, checkout the force field
    paper and the gromasc mannual
    """
    for d in dihedrals:
        print "{0:5d}{1:6d}{2:6d}{3:6d}{4:6d}".format(d[0], d[1], d[2], d[3], ft)

def print_martini_dihedrals(dihedrals, atoms, params):
    """
    atoms: the id:resname dict created by read_atoms
    params should be in the form:
    params = {
        # i.e. phase angle, force constant, multiplicity
        'GVPG': [[phi1, k1, n1], [ph2, k2, n2], [phi3, k3, n3] ... ],
        'VPGV': [[phi1, k1, n1], [ph2, k2, n2], [phi3, k3, n3] ... ],
        ....
        }
    Since MARTINI uses proper dih. function type 1
    """
    for d in dihedrals:
        dih_name = ''.join([three_to_one(atoms[di]) for di in d])
        for (phii, ki, ni) in params[dih_name]:
            print "{0:5d}{1:6d}{2:6d}{3:6d}{4:6d}{5:12.6f}{6:12.6f}{7:6d}".format(
                d[0], d[1], d[2], d[3], 1,
                phii, ki, ni)


# def determine_angle(b1, b2):
#     rb1 = copy.copy(b1)
#     rb2 = copy.copy(b2)
    
#     rb1.reverse()
#     rb2.reverse()

#     for i in [b1, rb1]:
#         for j in [b2, rb2]:
#             if i[1] == j[0]:
#                 return i + [j[1]]

# angles = []
# for i, b1 in enumerate(bonds):
#     for j, b2 in enumerate(bonds):
#         if i < j:
#             a = determine_angle(b1, b2)
#             if a:
#                 angles.append(a)

# for a in angles:
#     print "{0:5d}{1:6d}{2:6d}{3:6d}".format(a[0], a[1], a[2], 3)
# print len(angles)

# params = 

# this has been verified that my created [dihedrals] is exactly the same as Mikyung's 
# itpfile = '/home/zyxue/Dropbox/labwork/CG_param/CG_pgv12_WDihePot.itp'

itpfile = sys.argv[1]

atoms = read_atoms(itpfile)
# pp(atoms)

# bonds = read_bond_pairs('hep.itp', ff='opls')               # tested, the result is correct
# bonds = read_bond_pairs(itpfile, ff='martini')
bonds = read_bond_pairs(itpfile, ff='cgenff')
# pp(bonds)

dihedrals = collect_dihedrals(bonds)
print_dihedrals(dihedrals, ft=9)
# print_martini_dihedrals(dihedrals, atoms, params=cg_params)
