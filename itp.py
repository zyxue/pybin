#! /usr/bin/env python

"""This is script is incomplete, it's used to produce the itp file for opls,
given the input of all bonds"""

import re
import copy
from Bio.PDB.Polypeptide import three_to_one
from cg_params import PARAMS

cg_params = PARAMS().value

def read_atoms(itpfile):
    """get the id: resname correspondence for MARTINI when constructing [
    dihedrals ] """
    atoms = {}
    with open(itpfile, 'r') as inf:
        for line in inf:
            if re.search("^(?!;).*\[ *atoms *\]", line):
                # interested block begins here
                break

        for line in inf:
            if re.search("^(?!;).*\[ *bonds *\]", line):
                # interested block ends here
                break
            elif line.startswith(";") or line.startswith("[") or not line.split():
                # pass comment line, empty line or [ contraints ] line in MARTINI
                pass
            else:
                sl = line.split()
                atoms[int(sl[0])] = sl[3]
    return atoms

def read_bond_pairs(itpfile, ff):
    """
    to use this function, a preliminary itp file should have been generated in advance;

    ff could be "martini", "opls";

    if ff="martini", itpfile should be generated by MARTINI relavant script and
    contains the following two lines:
    [ bonds ]
    ;backbone-sidechain bonds
    """

    # flags for the beginning and ending lines of the interested block
    block_beg_end_flags = { 
        "martini": [";backbone-backbone bonds", ";backbone-sidechain bonds"],
        # "martini": [";backbone-backbone bonds", "^(?!;).*\[ *angles *\]"],
        # MARTINI has the "[ constraints ]" section and it only counts BBBB dihedrals
        "opls"   : ["^(?!;).*\[ *bonds *\]", "^(?!;).*\[ *pairs *\]"],
        }

    bonds = []

    with open(itpfile, 'r') as inf:
        for line in inf:
            if re.search(block_beg_end_flags[ff][0], line):
                # interested block begins here
                break

        for line in inf:
            if re.search(block_beg_end_flags[ff][1], line):
                # interested block ends here
                break
            # elif re.search("^[;\[]", line) or not line.split():
            elif line.startswith(";") or line.startswith("[") or not line.split():
                # pass comment line, empty line or [ contraints ] line in MARTINI
                pass
            else:
                bonds.append([int(i) for i in line.split()[:2]])
                # bonds.append([int(i) for i in line.split()[:2]])
    return bonds


def determine_dihedral(b1, b2, b3):
    rb1 = copy.copy(b1)
    rb2 = copy.copy(b2)
    rb3 = copy.copy(b3)

    rb1.reverse()                                           # reversed bond1
    rb2.reverse()
    rb3.reverse()

    for i in [b1, rb1]:
        for j in [b2, rb2]:
            for k in [b3, rb3]:
                if i[1] == j[0] and j[1] == k[0]:
                    return i + k

def collect_dihedrals(bonds):
    # dihedrals be determined based on bonds info
    dihedrals = []
    for i, b1 in enumerate(bonds):
        for j, b2 in enumerate(bonds):
            for k, b3 in enumerate(bonds):
                if i < j < k:
                    d = determine_dihedral(b1, b2, b3)
                    if d:
                        dihedrals.append(d)
    dihedrals.sort()
    return dihedrals

def print_dihedrals(dihedrals, ft=3):
    """
    if not sure what ft (function_type) should be used, checkout the force field
    paper and the gromasc mannual
    """
    for d in dihedrals:
        print "{0:5d}{1:6d}{2:6d}{3:6d}{4:6d}".format(d[0], d[1], d[2], d[3], ft)

def print_martini_dihedrals(dihedrals, atoms, params):
    """
    atoms: the id:resname dict created by read_atoms
    params should be in the form:
    params = {
        # i.e. phase angle, force constant, multiplicity
        'GVPG': [[phi1, k1, n1], [ph2, k2, n2], [phi3, k3, n3] ... ],
        'VPGV': [[phi1, k1, n1], [ph2, k2, n2], [phi3, k3, n3] ... ],
        ....
        }
    Since MARTINI uses proper dih. function type 1
    """
    for d in dihedrals:
        dih_name = ''.join([three_to_one(atoms[di]) for di in d])
        for (phii, ki, ni) in params[dih_name]:
            print "{0:5d}{1:6d}{2:6d}{3:6d}{4:6d}{5:12.6f}{6:12.6f}{7:6d}".format(
                d[0], d[1], d[2], d[3], 1,
                phii, ki, ni)


# def determine_angle(b1, b2):
#     rb1 = copy.copy(b1)
#     rb2 = copy.copy(b2)
    
#     rb1.reverse()
#     rb2.reverse()

#     for i in [b1, rb1]:
#         for j in [b2, rb2]:
#             if i[1] == j[0]:
#                 return i + [j[1]]

# angles = []
# for i, b1 in enumerate(bonds):
#     for j, b2 in enumerate(bonds):
#         if i < j:
#             a = determine_angle(b1, b2)
#             if a:
#                 angles.append(a)

# for a in angles:
#     print "{0:5d}{1:6d}{2:6d}{3:6d}".format(a[0], a[1], a[2], 3)
# print len(angles)

# params = 

from pprint import pprint as pp
# this has been verified that my created [dihedrals] is exactly the same as Mikyung's 
# itpfile = '/home/zyxue/Dropbox/labwork/CG_param/CG_pgv12_WDihePot.itp'

itpfile = 'sq1_cg_dih.itp'

atoms = read_atoms(itpfile)
# pp(atoms)

# bonds = read_bond_pairs('hep.itp', ff='opls')               # tested, the result is correct
bonds = read_bond_pairs(itpfile, ff='martini')
# pp(bonds)

dihedrals = collect_dihedrals(bonds)
print_martini_dihedrals(dihedrals, atoms, params=cg_params)
