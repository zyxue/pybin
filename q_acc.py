#!/usr/bin/env python

"""
This module is widely imported in the other q_xx.py files as for initialization
or decoration of the final plot
"""

import glob
import argparse
import re

import matplotlib.pyplot as plt
import numpy as np

__all__ = ['gen_len_to_num_map', 'det_row_col', 'get_id', 'show_or_save',
           'det_raw_lim', 'det_final_lim', 'decorate', 'parse_cmd']
__version__ = '1.0'

def gen_len_to_num_map(rg=[1,50]):
    """
    generate the number of subplots based on the length of input file list
    """
    a, b = rg
    len2num = {}
    for num in range(a,b):
        for i in range(a,b):
            if num % i == 0:
                j = num / i
                if abs(i-j) <= 2 and i >= j:
                    if num in pairs.keys():
                        pass
                    else:
                        pairs[num]=[i,j]
    return len2num

def det_row_col(len_of_infiles, more_rows_flag=True):
    """
    determine the number of rows and columns, maximum number of input files: 49
    """
    len2num = {
        1: [1, 1], 2: [2, 1], 3: [3, 1], 4: [2, 2], 6: [3, 2], 8: [4, 2], 
        9: [3, 3], 12: [4, 3], 15: [5, 3], 16: [4, 4], 20: [5, 4], 24: [6, 4],
        25: [5, 5], 30: [6, 5], 35: [7, 5], 36: [6, 6], 42: [7, 6], 48: [8, 6], 
        49: [7, 7]
        }                # this map is generated by gen_len_to_num_map function

    l = len_of_infiles
    keys = sorted(len2num.keys())
    assert l > 0 and l <= max(keys), "%d input files, zero or too many!!!" % l

    if l in keys:
        row_col = len2num[l]
    else:
        for i in range(1,len(keys)):
            if keys[i-1] < l < keys[i]:
                row_col = len2num[keys[i]]
    if not more_rows_flag:
        row_col.reverse()
    return row_col

def get_id(infiles=[]):
    """ Get the common id from multiples input files, but ONLY works for
    systems like sq1w300 at present (2011-05-19)"""

    if len(infiles) == 0:
        raise ValueError(
            "More than one file must be provided!!!")
    ids = []
    template = re.compile('sq[1-9][wm]')
    for f in infiles:
        ids.append(template.search(f).group())
    if len(set(ids)) == 1:
        return ids[0]
    else:
        raise ValueError(
            "infiles may have different ids, please check:\n %r" % infiles)


def show_or_save(outputfile):
    if outputfile: # if the name of outputfile is specified, then save, else plt.show()
        plt.savefig(outputfile)
    else:
        plt.show()

def det_raw_lim(keys,ps):
    """keys is a list, xps is a dictionary;
    1. collect all the max(min)_ps; 2. get the max(min) out of the max(min)_ps"""
    min_ps, max_ps = [], []
    for k in keys:
        assert len(ps[k]) > 0, "ps[%s]: %r" % (k, ps[k])
        min_ps.append(min(ps[k]))
        max_ps.append(max(ps[k]))
    lim = [min(min_ps)*0.9, max(max_ps)*1.1]
    return lim

def det_final_lim(keys, ps, b=None, e=None):
    if b is None or e is None:
        lim = det_raw_lim(keys,  ps)
        if b is None and e is not None:
            lim[1] = e
        elif b is not None and e is None:
            lim[0] = b
    else: 
        lim = [b, e]
    return lim

def decorate(keys, xps, yps, axes, blegend, xlb, ylb, xb, yb, xe, ye):
    """keys is a list,  xps,  yps are dictionaries"""
    xlim = det_final_lim(keys, xps, xb, xe)
    ylim = det_final_lim(keys, yps, yb, ye)
    for ax in axes:
        ax.set_xlabel(xlb, fontsize=20)
        ax.set_ylabel(ylb, fontsize=20)
        ax.set_xlim(xlim)
        ax.set_ylim(ylim)
        # from matplotlib.ticker import MultipleLocator,  FormatStrFormatter
        # dx = (xlim[1]-xlim[0])/5.
        # xmajorlocator = round(dx,  np.ceil(abs(np.log10(dx))))
        # ax.xaxis.set_major_locator(MultipleLocator(xmajorlocator))
        # ax.xaxis.set_minor_locator(MultipleLocator(xmajorlocator/10.))
        # dy = (ylim[1]-ylim[0])/5.
        # ymajorlocator = round(dy,  np.ceil(abs(np.log10(dy))))
        # ax.yaxis.set_major_locator(MultipleLocator(ymajorlocator))
        # ax.yaxis.set_minor_locator(MultipleLocator(ymajorlocator/10.))
        # ax.grid(b=True,  which='minor')
        ax.grid(b=True)
        if blegend:
            ax.legend(loc=0)

def convert_bins(option, opt_str, value, parser):
    v = value.split(',')
    if len(v) == 1:
        parser.values.bins = int(v[0])
    elif len(v) == 3:
        min_, max_, interval = [float(i) for i in v]
        parser.values.bins = np.arange(min_, max_, interval)

class convert_bins(argparse.Action):
    def __call__(self, parser, namespace, values, optoin_string=None):
        assert len(values) == 3
        final_values = np.arange(*values)
        setattr(namespace, self.dest, final_values)        

# def find_the_files(option, opt_str, value, parser):
#     infiles = []
#     infs = value.split()
#     for f in infs:
#         infiles.extend(glob.glob(f))
#     setattr(parser.values, option.dest, infiles)

def parse_cmd(cmd=None):
    parser = argparse.ArgumentParser('usage: %prog [options] **args')
    parser.add_argument('-f', type=str, dest='fs', default=None, nargs="+",
                        help='specify this option if plotting only one property')
    parser.add_argument('--xlb', type=str, default='x', dest='xlb', 
                        help='bottom label')
    parser.add_argument('--ylb', type=str, default='y', dest='ylb', 
                        help='left label')
    parser.add_argument('--xb', type=float, default=None, dest='xb', 
                        help='specifly x beginning')
    parser.add_argument('--xe', type=float, default=None, dest='xe', 
                        help='specifly x ending')
    parser.add_argument('--yb', type=float, default=None, dest='yb', 
                        help='specifly y beginning')
    parser.add_argument('--ye', type=float, default=None, dest='ye', 
                        help='specifly y ending')
    parser.add_argument('--title', type=str, default=None, dest='title', 
                        help='specifly the title when plot on a single subplot')
    parser.add_argument('--legend', action='store_true', default=False, dest='blegend', 
                        help='specifly the legend, otherwise, no legends will show up for q_subplots.py')
    parser.add_argument('--template_for_legend', type=str, default=None, dest='template_for_legend', 
                        help='find the legend from the file name useing regex')
    parser.add_argument('--bins', type=str, default="100", dest='bins', nargs='+', action=convert_bins,
                        help=('specify this options if plotting histogram,'
                              'could be a number of bins or a string containing 3 values'
                              '(i.e min, max, interval, e.g. "0.6, 2.0, 0.02")'))
    parser.add_argument('-o', type=str, default=None, dest='of', 
                        help='specifly output file OPT.')
    parser.add_argument('--ap', action="store_true", default=None, dest='ap', 
                        help='plot_all_properties?')
    parser.add_argument('--overlap', type=int, default=None, dest='overlap',
                        help='put multiple subplots together.')
    parser.add_argument('--nm', action="store_true", default=None, dest='nm', 
                        help='x axis normalized by 1000 or not? usefule when x values are large,  OPT.')
    parser.add_argument('--eb', action="store_true", default=None, dest='eb', 
                        help='plot error bar or not,  OPT.')
    parser.add_argument('--scol', action="store_true", default=None, dest='scol', 
                        help='use scol or not,  otherwise,  use scol,  OPT.')
    parser.add_argument('--ndx', type=str, dest='ndx', 
                        help='ndx file when calculating turns.')
    parser.add_argument('--gro', type=str, dest='gro', 
                        help='gro file when calculating turns.')
    parser.add_argument('--xpm', type=str, dest='xpm', 
                        help='xpm file when calculating turns.')
    parser.add_argument('--morer', action='store_true', dest='morer', default=False, 
                        help='when multiple subplots are needed,  more rows or more columns,  default is more rows.')
    parser.add_argument('--mysys', action='store_true', dest='mysys', default=False, 
                        help='whether to use those properties specified in mysys.dat or not.')
    
    group = parser.add_argument_group("xy",  "use these options when the x & y data are from different files")
    
    group.add_argument('--xf', type=str, dest='xf', 
                       help='file containing the property along the x axis')
    group.add_argument('--yf', type=str, dest='yf', 
                       help='file containing the property along the y axis')
    group.add_argument('--xcol', type=int, default=1, dest='xcol', 
                       help='specifly the num of the column on the x axis')
    group.add_argument('--ycol', type=int, default=2, dest='ycol', 
                       help='specifly the num of the column on the y axis ')
    
    parser.add_argument_group(group)
    args = parser.parse_args(cmd)
    return args

if __name__ == '__main__':
    options = parse_cmd()
    print options.fs
    print options.overlap
