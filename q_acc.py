#!/usr/bin/env python

"""
This module is widely imported in the other q_xx.py files as for initialization
or decoration of the final plot
"""

import glob
import optparse
import sys
import re

import matplotlib.pyplot as plt
import numpy as np

from xvg2png import xvg2array

__all__ = ['gen_len_to_num_map', 'det_row_col', 'get_id', 'show_or_save',
           'det_raw_lim', 'det_final_lim', 'decorate', 'parse_cmd']
__version__ = '1.0'

def gen_len_to_num_map(rg=[1,50]):
    """
    generate the number of subplots based on the length of input file list
    """
    a, b = rg
    len2num = {}
    for num in range(a,b):
        for i in range(a,b):
            if num % i == 0:
                j = num / i
                if abs(i-j) <= 2 and i >= j:
                    if num in pairs.keys():
                        pass
                    else:
                        pairs[num]=[i,j]
    return len2num

def det_row_col(len_of_infiles, more_rows_flag=True):
    """
    determine the number of rows and columns, maximum number of input files: 49
    """
    len2num = {
        1: [1, 1], 2: [2, 1], 3: [3, 1], 4: [2, 2], 6: [3, 2], 8: [4, 2], 
        9: [3, 3], 12: [4, 3], 15: [5, 3], 16: [4, 4], 20: [5, 4], 24: [6, 4],
        25: [5, 5], 30: [6, 5], 35: [7, 5], 36: [6, 6], 42: [7, 6], 48: [8, 6], 
        49: [7, 7]
        }                # this map is generated by gen_len_to_num_map function

    l = len_of_infiles
    keys = sorted(len2num.keys())
    assert l > 0 and l <= max(keys), "%d input files, zero or too many!!!" % l

    if l in keys:
        row_col = len2num[l]
    else:
        for i in range(1,len(keys)):
            if keys[i-1] < l < keys[i]:
                row_col = len2num[keys[i]]
    if not more_rows_flag:
        row_col.reverse()
    return row_col

def get_id(infiles=[]):
    """ Get the common id from multiples input files, but ONLY works for
    systems like sq1w300 at present (2011-05-19)"""

    if len(infiles) == 0:
        raise ValueError(
            "More than one file must be provided!!!")
    ids = []
    template = re.compile('sq[1-9][wm]')
    for f in infiles:
        ids.append(template.search(f).group())
    if len(set(ids)) == 1:
        return ids[0]
    else:
        raise ValueError(
            "infiles may have different ids, please check:\n %r" % infiles)


def show_or_save(outputfile):
    if outputfile: # if the name of outputfile is specified, then save, else plt.show()
        plt.savefig(outputfile)
    else:
        plt.show()

def det_raw_lim(keys,ps):
    """keys is a list, xps is a dictionary;
    1. collect all the max(min)_ps; 2. get the max(min) out of the max(min)_ps"""
    min_ps, max_ps = [], []
    for k in keys:
        assert len(ps[k]) > 0, "ps[%s]: %r" % (k, ps[k])
        min_ps.append(min(ps[k]))
        max_ps.append(max(ps[k]))
    lim = [min(min_ps)*0.9, max(max_ps)*1.1]
    return lim

def det_final_lim(keys,ps,b=None,e=None):
    if b is None or e is None:
        lim = det_raw_lim(keys, ps)
        if b is None and e is not None:
            lim[1] = e
        elif b is not None and e is None:
            lim[0] = b
    else: 
        lim = [b,e]
    return lim

def decorate(keys,xps,yps,axes,options):
    """keys is a list, xps, yps are dictionaries"""
    xlim = det_final_lim(keys,xps,options.xb,options.xe)
    ylim = det_final_lim(keys,yps,options.yb,options.ye)
    for ax in axes:
        ax.set_xlabel(options.xlb,fontsize=20)
        ax.set_ylabel(options.ylb,fontsize=20)
        ax.set_xlim(xlim)
        ax.set_ylim(ylim)
        if options.title:
            ax.set_title(options.title,fontsize=30)
        # from matplotlib.ticker import MultipleLocator, FormatStrFormatter
        # dx = (xlim[1]-xlim[0])/5.
        # xmajorlocator = round(dx, np.ceil(abs(np.log10(dx))))
        # ax.xaxis.set_major_locator(MultipleLocator(xmajorlocator))
        # ax.xaxis.set_minor_locator(MultipleLocator(xmajorlocator/10.))
        # dy = (ylim[1]-ylim[0])/5.
        # ymajorlocator = round(dy, np.ceil(abs(np.log10(dy))))
        # ax.yaxis.set_major_locator(MultipleLocator(ymajorlocator))
        # ax.yaxis.set_minor_locator(MultipleLocator(ymajorlocator/10.))
        # ax.grid(b=True, which='minor')
        ax.grid(b=True)

def convert_bins(option, opt_str, value, parser):
    v = value.split(',')
    if len(v) == 1:
        parser.values.bins = int(v[0])
    elif len(v) == 3:
        min_, max_, interval = [float(i) for i in v]
        parser.values.bins = np.arange(min_, max_, interval)

def find_the_files(option, opt_str, value, parser):
    infiles = []
    infs = value.split()
    print infs
    for f in infs:
        infiles.extend(glob.glob(f))
    del parser.rargs[:len(value)]
    setattr(parser.values, option.dest, infiles)

def parse_cmd(cmd=None):
    parser = optparse.OptionParser('usage: %prog [options] **args')
    # parser.add_option('-f', type='str', dest='fs', help='specify this option if plotting only one property'
    parser.add_option('-f', type='str', dest='fs', default=None, action="callback", callback=find_the_files,
                      help='specify this option if plotting only one property')
    parser.add_option('--xlb', type='str', default='x', dest='xlb', help='bottom label')
    parser.add_option('--ylb', type='str', default='y', dest='ylb', help='left label')
    parser.add_option('--xb', type='float', default=None, dest='xb', help='specifly x beginning')
    parser.add_option('--xe', type='float', default=None, dest='xe', help='specifly x ending')
    parser.add_option('--yb', type='float', default=None, dest='yb', help='specifly y beginning')
    parser.add_option('--ye', type='float', default=None, dest='ye', help='specifly y ending')
    parser.add_option('--title', type='str', default=None, dest='title', 
                      help='specifly the title when plot on a single subplot')
    parser.add_option('--bins', type='str', default="100", dest='bins', action='callback', callback=convert_bins,
                      help='specify this options if plotting histogram, could be a number of bins or a string containing 3 values (i.e min, max, interval, e.g. "0.6, 2.0, 0.02"')
    parser.add_option('-o', type='str', default=None, dest='of', help='specifly output file OPT.')
    parser.add_option('--ap', action="store_true", default=None, dest='ap', help='plot_all_properties?')
    parser.add_option('--overlap', type="int", default=None, dest='overlap', help='put multiple subplots together.')
    parser.add_option('--nm', action="store_true", default=None, dest='nm', 
                      help='x axis normalized by 1000 or not? usefule when x values are large,  OPT.')
    parser.add_option('--eb', action="store_true", default=None, dest='eb', help='plot error bar or not,  OPT.')
    parser.add_option('--scol', action="store_true", default=None, dest='scol', 
                      help='use scol or not,  otherwise,  use scol,  OPT.')
    parser.add_option('--ndx', type='str', dest='ndx', help='ndx file when calculating turns.')
    parser.add_option('--gro', type='str', dest='gro', help='gro file when calculating turns.')
    parser.add_option('--xpm', type='str', dest='xpm', help='xpm file when calculating turns.')
    parser.add_option('--morer', action='store_true', dest='morer', default=False, 
                      help='when multiple subplots are needed,  more rows or more columns,  default is more rows.')
    group = optparse.OptionGroup(parser,  "xy",  "use these options when the x & y data are from different files")

    group.add_option('--xf', type='str', dest='xf', help='file containing the property along the x axis')
    group.add_option('--yf', type='str', dest='yf', help='file containing the property along the y axis')
    group.add_option('--xcol', type='int', default=1, dest='xcol', 
                     help='specifly the num of the column on the x axis')
    group.add_option('--ycol', type='int', default=2, dest='ycol', 
                     help='specifly the num of the column on the y axis ')

    parser.add_option_group(group)
    # if cmd:
    #     options, args = parser.parse_args(cmd)
    # else:
    #     options, args = parser.parse_args(cmd)

    options, args = parser.parse_args(cmd)
    return options

if __name__ == '__main__':
    options = parse_cmd()

